#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>

// --- Token Definitions ---
typedef enum {
    TOKEN_EOF = -1,
    TOKEN_ERROR = 0,
    TOKEN_INT_KEYWORD,
    TOKEN_IDENTIFIER,
    TOKEN_ASSIGN_OP, // =
    TOKEN_SEMICOLON, // ;
    TOKEN_NUMBER,
    TOKEN_LPAREN,    // (
    TOKEN_RPAREN,    // )
    TOKEN_LBRACE,    // {
    TOKEN_RBRACE,    // }
    TOKEN_IF_KEYWORD
} TokenType;

typedef struct {
    TokenType type;
    char lexeme[256];
} Token;

// --- Global Variables for Lexer and Parser ---
char *input_code;       // Pointer to the input C code string
int current_pos = 0;    // Current reading position in the input_code
Token current_token;    // The token currently being processed by the parser

// --- Lexer (Scanner) Functions ---

// Moves to the next non-whitespace character
void skip_whitespace() {
    while (isspace(input_code[current_pos])) {
        current_pos++;
    }
}

// Gets the next token from the input_code
Token get_next_token() {
    skip_whitespace();

    Token token;
    token.type = TOKEN_ERROR;
    token.lexeme[0] = '\0';

    char c = input_code[current_pos];

    if (c == '\0') {
        token.type = TOKEN_EOF;
        strcpy(token.lexeme, "EOF");
        return token;
    }

    // Identifiers and Keywords
    if (isalpha(c) || c == '_') {
        int i = 0;
        while (isalnum(input_code[current_pos]) || input_code[current_pos] == '_') {
            token.lexeme[i++] = input_code[current_pos++];
            if (i >= 255) break; // Prevent buffer overflow
        }
        token.lexeme[i] = '\0';

        if (strcmp(token.lexeme, "int") == 0) {
            token.type = TOKEN_INT_KEYWORD;
        } else if (strcmp(token.lexeme, "if") == 0) {
            token.type = TOKEN_IF_KEYWORD;
        } else {
            token.type = TOKEN_IDENTIFIER;
        }
        return token;
    }

    // Numbers
    if (isdigit(c)) {
        int i = 0;
        while (isdigit(input_code[current_pos])) {
            token.lexeme[i++] = input_code[current_pos++];
            if (i >= 255) break;
        }
        token.lexeme[i] = '\0';
        token.type = TOKEN_NUMBER;
        return token;
    }

    // Operators and Punctuation
    switch (c) {
        case '=':
            token.type = TOKEN_ASSIGN_OP;
            strcpy(token.lexeme, "=");
            break;
        case ';':
            token.type = TOKEN_SEMICOLON;
            strcpy(token.lexeme, ";");
            break;
        case '(':
            token.type = TOKEN_LPAREN;
            strcpy(token.lexeme, "(");
            break;
        case ')':
            token.type = TOKEN_RPAREN;
            strcpy(token.lexeme, ")");
            break;
        case '{':
            token.type = TOKEN_LBRACE;
            strcpy(token.lexeme, "{");
            break;
        case '}':
            token.type = TOKEN_RBRACE;
            strcpy(token.lexeme, "}");
            break;
        default:
            token.type = TOKEN_ERROR;
            token.lexeme[0] = c;
            token.lexeme[1] = '\0';
            fprintf(stderr, "Lexical Error: Unexpected character '%c' at position %d\n", c, current_pos);
            break;
    }
    current_pos++; // Consume the character
    return token;
}

// --- Parser Functions ---

// Error reporting function
void syntax_error(const char *expected_str) {
    fprintf(stderr, "Syntax Error: Expected %s, but found '%s' (Type: %d) at position %d\n",
            expected_str, current_token.lexeme, current_token.type, current_pos - strlen(current_token.lexeme));
    exit(1); // Exit on first error for simplicity
}

// Consumes the current token if it matches the expected type, otherwise reports an error
void match(TokenType expected_type, const char *expected_str) {
    if (current_token.type == expected_type) {
        current_token = get_next_token(); // Move to the next token
    } else {
        syntax_error(expected_str);
    }
}

// Forward declarations for recursive descent
void program();
void declaration();
void statement();
void expression();
void block();

// rule: program -> (declaration | statement)* EOF
void program() {
    current_token = get_next_token(); // Get the first token

    while (current_token.type != TOKEN_EOF) {
        if (current_token.type == TOKEN_INT_KEYWORD) {
            declaration();
        } else if (current_token.type == TOKEN_IDENTIFIER || current_token.type == TOKEN_IF_KEYWORD) {
            statement();
        } else {
            syntax_error("a declaration or a statement");
        }
    }
    printf("Parsing complete. No syntax errors found.\n");
}

// rule: declaration -> 'int' IDENTIFIER ';'
void declaration() {
    match(TOKEN_INT_KEYWORD, "'int' keyword");
    match(TOKEN_IDENTIFIER, "an identifier");
    match(TOKEN_SEMICOLON, "a semicolon ';'");
    printf("Parsed: Declaration\n");
}

// rule: statement -> assignment_statement | if_statement
// rule: assignment_statement -> IDENTIFIER '=' expression ';'
// rule: if_statement -> 'if' '(' expression ')' block
void statement() {
    if (current_token.type == TOKEN_IDENTIFIER) { // Assignment statement
        match(TOKEN_IDENTIFIER, "an identifier for assignment");
        match(TOKEN_ASSIGN_OP, "an assignment operator '='");
        expression();
        match(TOKEN_SEMICOLON, "a semicolon ';'");
        printf("Parsed: Assignment Statement\n");
    } else if (current_token.type == TOKEN_IF_KEYWORD) { // If statement
        match(TOKEN_IF_KEYWORD, "'if' keyword");
        match(TOKEN_LPAREN, "an opening parenthesis '('");
        expression(); // Condition
        match(TOKEN_RPAREN, "a closing parenthesis ')'");
        block();      // Body of the if statement
        printf("Parsed: If Statement\n");
    } else {
        syntax_error("an assignment statement or an if statement");
    }
}

// rule: expression -> IDENTIFIER | NUMBER
void expression() {
    if (current_token.type == TOKEN_IDENTIFIER) {
        match(TOKEN_IDENTIFIER, "an identifier for expression");
    } else if (current_token.type == TOKEN_NUMBER) {
        match(TOKEN_NUMBER, "a number literal");
    } else {
        syntax_error("an identifier or a number");
    }
    printf("Parsed: Expression\n");
}

// rule: block -> '{' (declaration | statement)* '}'
void block() {
    match(TOKEN_LBRACE, "an opening brace '{'");
    while (current_token.type != TOKEN_RBRACE && current_token.type != TOKEN_EOF) {
        if (current_token.type == TOKEN_INT_KEYWORD) {
            declaration();
        } else if (current_token.type == TOKEN_IDENTIFIER || current_token.type == TOKEN_IF_KEYWORD) {
            statement();
        } else {
            syntax_error("a declaration, a statement, or a closing brace '}'");
        }
    }
    match(TOKEN_RBRACE, "a closing brace '}'");
    printf("Parsed: Block\n");
}

// --- Main Function ---
int main() {
    // Example C code to analyze
    // This is a minimal subset for demonstration.
    // Try uncommenting lines with errors to see the error reporting.
    const char *code =
        "int x;\n"
        "x = 10;\n"
        "if (x) {\n"
        "    int y;\n"
        "    y = 5;\n"
        "}\n"
        "int z;\n";
        //"int ; // Error: missing identifier\n"
        //"a = ; // Error: missing expression\n"
        //"if (1 { } // Error: missing ')'\n"
        //"int func() { return 0; } // Not supported by this parser\n";

    input_code = (char *)malloc(strlen(code) + 1);
    if (input_code == NULL) {
        fprintf(stderr, "Memory allocation failed.\n");
        return 1;
    }
    strcpy(input_code, code);

    printf("Starting syntax analysis...\n\n");
    program(); // Start the parsing process

    free(input_code); // Free allocated memory
    return 0;
}
